#-----------------------------------------------------------------------------*
#
#  @file gtl_instructions.galgas
#
#  @section desc File description
#
#  Instructions of GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

#=============================================================================*
# A @gtlVarItem is a part of a variable path.
# For instance A::B["e"]::C::D[3] is a path. A is a struct, B is a field of
# A and is a map, ["e"] is the element of the map with key "e". This element
# is a struct with field C which is itself a struct with field D which is a
# list and we reference the element at index 3.
abstract class @gtlVarItem { }

#=============================================================================*
# Scalar struct field, ie A or C in the example above
class @gtlVarItemField : @gtlVarItem { @lstring field }

#-----------------------------------------------------------------------------*
# set a scalar field
override method @gtlVarItemField set
  ?!     @gtlVarMap  context
  ?  let @gtlVarPath path
  ?  let @gtlData    data
{ 
  if [path length] == 0 then
    # at the end, set the variable in the context
    if [context hasKey ![field string]] then
      # A field with the same name exists, replace it
      [!?context setMValueForKey !data ![field string]]
    else
      # The field does not exist, add it
      [!?context put !field !data]
    end
  else
    @gtlVarMap subContext = .emptyMap{}
    # not at the end, get and set the subcontext
    if [context hasKey ![field string]] then
      # get the variable
      [context get !field ?var @gtlData variable]
      cast variable
        case == @gtlStruct structVar :
          # it is a struct
          subContext = [structVar value]
      end
      # set in the subcontext
      [[path itemAtIndex !0] set !?subContext ![path subListFromIndex !1] !data]
      # update with the result
      [!?context setMValueForKey !@gtlStruct.new{![field location] !subContext} ![field string]]
    else
      # set in the subcontext
      [[path itemAtIndex !0] set !?subContext ![path subListFromIndex !1] !data]
      # update with the result
      [!?context put !field !@gtlStruct.new{![field location] !subContext}]
    end
  end
}

#=============================================================================*
# Map item struct field, ie B in the example above
class @gtlVarItemKey :   @gtlVarItemField { @lstring key }

#-----------------------------------------------------------------------------*
# set a map item field
override method @gtlVarItemKey set
  ?!     @gtlVarMap  context
  ?  let @gtlVarPath path
  ?  let @gtlData    data
{ 
  if [path length] == 0 then
    # at the end, set the variable in the context
    # 2 cases :
    # 1) the variable already exists and is a map, set or replace the element
    # 2) the variable already exists and is not a map, replace it with a map
    #    with the item set
    # 3) the variable does not exist, create a map and add the item
    if [context hasKey ![field string]] then
      # A field with the same name exists, get it
      [!?context del !field ?var @gtlData item]
      cast item
        case == @gtlMap mapItem :
          @gtlVarMap mapToSet = [mapItem value]
          if [mapToSet hasKey ![key string]] then
            # update it
            [!?mapToSet setMValueForKey !data ![key string]]
          else
            # create it
            [!?mapToSet put !key !data]
          end
          # update the context
          [!?context put !field !@gtlMap.new{![mapItem where] !mapToSet}]
        else
          # not a map, create one
          @gtlVarMap mapToSet = .emptyMap{}
          [!?mapToSet put !key !data]
          [!?context put !field !@gtlMap.new{![field location] !mapToSet}]
      end  
    else
      # The field does not exist, add it
      [!?context put !field !data]
    end
  else
    @gtlVarMap subContext = .emptyMap{}
    # not at the end, get and set the subcontext
    if [context hasKey ![field string]] then
      # get the variable
      [!?context del !field ?var @gtlData variable]
      cast variable
        case == @gtlMap mapVar :
          # it is a map, get the item corresponding to the key
          @gtlVarMap theMap = [mapVar value]
          if [theMap hasKey ![key string]] then
            [!?theMap del !key ?subContext]
          end
          [[path itemAtIndex !0] set !?subContext ![path subListFromIndex !1] !data]
          [!?context setMValueForKey !@gtlMap.new{![field location] !subContext} ![field string]]
        else
          # set in the subcontext
          [[path itemAtIndex !0] set !?subContext ![path subListFromIndex !1] !data]
          # update with the result
          [!?context put !field !@gtlMap.new{![field location] !subContext}]
      end
    else
      # set in the subcontext
      [[path itemAtIndex !0] set !?subContext ![path subListFromIndex !1] !data]
      # update with the result
      [!?context put !field !@gtlMap.new{![field location] !subContext}]
    end
  end
}

#=============================================================================*
# List item struct field, ie D in the example above
class @gtlVarItemIdx :   @gtlVarItemField { @lsint   idx }

#=============================================================================*
# A variable path is a list of variable items
list @gtlVarPath {
  @gtlVarItem item
}

#-----------------------------------------------------------------------------*
# Set a data in a path
method @gtlVarPath setMe ?!@gtlVarMap context ?let @gtlData data
{
  if [self length] > 0 then
    @gtlVarItem item = [self itemAtIndex !0]
    [item set !?context ![self subListFromIndex !1] !data]
  else
    error @location.here : "INTERNAL ERROR. A @gtlVarPath should not be an empty list"
  end
}

# abstact method to set a field in a context
abstract method @gtlVarItem set
  ?!     @gtlVarMap  context
  ?  let @gtlVarPath path
  ?  let @gtlData    data


# A variable map is a map of variables. Used for variables of a gtl program
# and used in struct and map of the language itself.
map @gtlVarMap {
  @gtlData mValue 
  insert put error message "a variable or field named '%K' is already declared in %L"
  search get error message "there is no variable or field named '%K'"
  remove del error message "there is no variable or field named '%K' to delete"
}

abstract class @gtlData { @location where %setter }

abstract getter @gtlData plusOp  -> @gtlData result
abstract getter @gtlData minusOp -> @gtlData result
abstract getter @gtlData notOp   -> @gtlData result
abstract getter @gtlData addOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData subOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData mulOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData divOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData andOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData orOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData xorOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData slOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData srOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData neqOp ?let @gtlData right -> @gtlData result
abstract getter @gtlData eqOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData ltOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData leOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData gtOp  ?let @gtlData right -> @gtlData result
abstract getter @gtlData geOp  ?let @gtlData right -> @gtlData result

#---------------------------------------------------------------------------*
# Int type and operations on int
#---------------------------------------------------------------------------*
class @gtlInt    : @gtlData { @sint64  value }
override getter @gtlInt plusOp  -> @gtlData result { result = self }
override getter @gtlInt minusOp -> @gtlData result { result = @gtlInt.new { !where !-value } }
override getter @gtlInt notOp   -> @gtlData result { result = @gtlInt.new { !where !~value } }
override getter @gtlInt addOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value + [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt subOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value - [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt mulOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value * [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt divOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value / [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt andOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value & [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt orOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value | [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt xorOp ?let @gtlData right -> @gtlData result {
  result = @gtlInt.new { !where !value ^ [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt slOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    @sint64 r = [right as @gtlInt value];
    if r >= 0LS then 
      result = @gtlInt.new { !where !value << [[right as @gtlInt value] uint] }
    else
      error [right where] : "positive int expected" : result
    end
  else
    error [right where] : "int expected" : result
  end
}
override getter @gtlInt srOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlInt then
    @sint64 r = [right as @gtlInt value];
    if r >= 0LS then 
      result = @gtlInt.new { !where !value >> [r uint] }
    else
      error [right where] : "positive int expected" : result
    end
  else
    error [right where] : "int expected" : result
  end
}
override getter @gtlInt neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlInt value] }
    error [right where] : "int expected" : result
}
override getter @gtlInt leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlInt value] }
    error [right where] : "int expected" : result
}

#---------------------------------------------------------------------------*
# Float type and operations on float
#---------------------------------------------------------------------------*
class @gtlFloat  : @gtlData { @double  value }
override getter @gtlFloat plusOp  -> @gtlData result { result = self }
override getter @gtlFloat minusOp -> @gtlData result { result = @gtlFloat.new { !where !-value } }
override getter @gtlFloat notOp   -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat addOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value + [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat subOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value - [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat mulOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value * [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat divOp ?let @gtlData right -> @gtlData result {
  result = @gtlFloat.new { !where !value / [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat andOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat orOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat slOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat srOp ?let @gtlData unused right -> @gtlData result {
  error where : "float forbidden" : result
}
override getter @gtlFloat neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}
override getter @gtlFloat leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlFloat value] }
    error [right where] : "float expected" : result
}

#---------------------------------------------------------------------------*
# String type and operations on string
#---------------------------------------------------------------------------*
class @gtlString : @gtlData { @string  value }
override getter @gtlString plusOp  -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString minusOp -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString notOp   -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString addOp ?let @gtlData right -> @gtlData result {
  result = @gtlString.new { !where !value + [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString subOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString divOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString andOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString orOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString slOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString srOp ?let @gtlData unused right -> @gtlData result {
  error where : "string forbidden" : result
}
override getter @gtlString neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlString value] }
    error [right where] : "string expected" : result
}
override getter @gtlString leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlString value] }
    error [right where] : "string expected" : result
}

#---------------------------------------------------------------------------*
# Bool type and operations on bool
#---------------------------------------------------------------------------*
class @gtlBool   : @gtlData { @bool    value }
override getter @gtlBool plusOp  -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool minusOp -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool notOp   -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool addOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool subOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool divOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool andOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value & [right as @gtlBool value] }
    error [right where] : "bool expected" : result
}
override getter @gtlBool orOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value | [right as @gtlBool value] }
    error [right where] : "bool expected" : result
}
override getter @gtlBool xorOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value ^ [right as @gtlBool value] }
    error [right where] : "bool expected" : result
}
override getter @gtlBool slOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool srOp ?let @gtlData unused right -> @gtlData result {
  error where : "bool forbidden" : result
}
override getter @gtlBool neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value != [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value == [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool gtOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value > [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool geOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value >= [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool ltOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value < [right as @gtlBool value] }
    error [right where] : "string expected" : result
}
override getter @gtlBool leOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !value <= [right as @gtlBool value] }
    error [right where] : "string expected" : result
}

#---------------------------------------------------------------------------*
# foundation types for collections
#---------------------------------------------------------------------------*
list @list { @gtlVarMap value }

#---------------------------------------------------------------------------*
# Struct type and operations on struct
#---------------------------------------------------------------------------*
class @gtlStruct : @gtlData { @gtlVarMap  value }
override getter @gtlStruct plusOp  -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct minusOp -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct notOp   -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct addOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct subOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct divOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct andOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct orOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct slOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct srOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value != [right as @gtlStruct value]) }
    error [right where] : "struct expected" : result
}
override getter @gtlStruct eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value == [right as @gtlStruct value]) }
    error [right where] : "struct expected" : result
}
override getter @gtlStruct gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct geOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}
override getter @gtlStruct leOp ?let @gtlData unused right -> @gtlData result {
  error where : "struct forbidden" : result
}

#---------------------------------------------------------------------------*
# List type and operations on lists
#---------------------------------------------------------------------------*
class @gtlList   : @gtlData { @list value }
override getter @gtlList plusOp  -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList minusOp -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList notOp   -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList addOp ?let @gtlData right -> @gtlData result {
  if right is == @gtlList then
    result = @gtlList.new { !where !value + [right as @gtlList value] }
  elsif right is == @gtlStruct then
    @list res = value;
    res += ![right as @gtlStruct value]
    result = @gtlList.new { !where !res  }
  else
    error [right where] : "list or struct expected" : result
  end
}
override getter @gtlList subOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList divOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList andOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList orOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList slOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList srOp ?let @gtlData unused right -> @gtlData result {
  error where : "list forbidden" : result
}
override getter @gtlList neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value != [right as @gtlList value]) }
    error [right where] : "list expected" : result
}
override getter @gtlList eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value == [right as @gtlList value]) }
    error [right where] : "list expected" : result
}
override getter @gtlList gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the > operator" : result
}
override getter @gtlList geOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the >= operator" : result
}
override getter @gtlList ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the < operator" : result
}
override getter @gtlList leOp ?let @gtlData unused right -> @gtlData result {
  error where : "a list does not support the <= operator" : result
}

#---------------------------------------------------------------------------*
# Map type and operations on maps
#---------------------------------------------------------------------------*
class @gtlMap    : @gtlData { @gtlVarMap  value %setter }
override getter @gtlMap plusOp  -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap minusOp -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap notOp   -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap addOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap subOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap mulOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap divOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap andOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap orOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap xorOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap slOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap srOp ?let @gtlData unused right -> @gtlData result {
  error where : "map forbidden" : result
}
override getter @gtlMap neqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value != [right as @gtlMap value]) }
    error [right where] : "map expected" : result
}
override getter @gtlMap eqOp ?let @gtlData right -> @gtlData result {
  result = @gtlBool.new { !where !(value == [right as @gtlMap value]) }
    error [right where] : "map expected" : result
}
override getter @gtlMap gtOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the > operator" : result
}
override getter @gtlMap geOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the >= operator" : result
}
override getter @gtlMap ltOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the < operator" : result
}
override getter @gtlMap leOp ?let @gtlData unused right -> @gtlData result {
  error where : "a map does not support the <= operator" : result
}

#---------------------------------------------------------------------------*
# abstract classes for an expression
#---------------------------------------------------------------------------*
abstract class @gtlExpression { @location where }
abstract class @gtlUnaryExpression : @gtlExpression {
  @gtlExpression son
}
abstract class @gtlBinaryExpression : @gtlExpression {
  @gtlExpression lSon
  @gtlExpression rSon
}

abstract getter @gtlExpression eval -> @gtlData result

#===========================================================================*
# class for a literal terminal
#---------------------------------------------------------------------------*
class @gtlTerminal : @gtlExpression { @gtlData value }
override getter @gtlTerminal eval -> @gtlData result { result = value }

#===========================================================================*
# classes for unary expressions
#---------------------------------------------------------------------------*
# @gtlParenthesizedExpression : ( son )
#---------------------------------------------------------------------------*
class @gtlParenthesizedExpression : @gtlUnaryExpression {}
override getter @gtlParenthesizedExpression eval -> @gtlData result {
  result = [son eval]
  [!?result setWhere !where]
}

#---------------------------------------------------------------------------*
# @gtlMinusExpression : unary -. Does a - son
#---------------------------------------------------------------------------*
class @gtlMinusExpression : @gtlUnaryExpression {}
override getter @gtlMinusExpression eval -> @gtlData result {
  result = [[son eval] minusOp]
}

#---------------------------------------------------------------------------*
# @gtlPlusExpression : unary +. Does a + son 
#---------------------------------------------------------------------------*
class @gtlPlusExpression : @gtlUnaryExpression {}
override getter @gtlPlusExpression eval -> @gtlData result {
  result = [[son eval] plusOp]
}

#---------------------------------------------------------------------------*
# @gtlTildeExpression : unary bitwise not or boolean not. Does a ~ son 
#---------------------------------------------------------------------------*
class @gtlNotExpression : @gtlUnaryExpression {}
override getter @gtlNotExpression eval -> @gtlData result {
  result = [[son eval] notOp]
}

#===========================================================================*
# classes for binary expressions
#---------------------------------------------------------------------------*
# @gtlAddExpression : binary add. Does a lSon + rSon
#---------------------------------------------------------------------------*
class @gtlAddExpression : @gtlBinaryExpression {}
override getter @gtlAddExpression eval -> @gtlData result {
  result = [[lSon eval] addOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlSubstractExpression : binary substract. Does a lSon - rSon
#---------------------------------------------------------------------------*
class @gtlSubstractExpression : @gtlBinaryExpression {}
override getter @gtlSubstractExpression eval -> @gtlData result {
  result = [[lSon eval] subOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlMultiplyExpression : binary multiply. Does a lSon * rSon
#---------------------------------------------------------------------------*
class @gtlMultiplyExpression : @gtlBinaryExpression {}
override getter @gtlMultiplyExpression eval -> @gtlData result {
  result = [[lSon eval] mulOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlDivideExpression : binary divide. Does a lSon / rSon
#---------------------------------------------------------------------------*
class @gtlDivideExpression : @gtlBinaryExpression {}
override getter @gtlDivideExpression eval -> @gtlData result {
  result = [[lSon eval] divOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlAndExpression : binary and. Does a lSon & rSon
#---------------------------------------------------------------------------*
class @gtlAndExpression : @gtlBinaryExpression {}
override getter @gtlAndExpression eval -> @gtlData result {
  result = [[lSon eval] andOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlOrExpression : binary or. Does a lSon | rSon
#---------------------------------------------------------------------------*
class @gtlOrExpression : @gtlBinaryExpression {}
override getter @gtlOrExpression eval -> @gtlData result {
  result = [[lSon eval] orOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlXorExpression : binary or. Does a lSon ^ rSon
#---------------------------------------------------------------------------*
class @gtlXorExpression : @gtlBinaryExpression {}
override getter @gtlXorExpression eval -> @gtlData result {
  result = [[lSon eval] xorOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlShiftLeftExpression : Does a lSon << rSon
#---------------------------------------------------------------------------*
class @gtlShiftLeftExpression : @gtlBinaryExpression {}
override getter @gtlShiftLeftExpression eval -> @gtlData result {
  result = [[lSon eval] slOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlShiftRightExpression : Does a lSon >> rSon
#---------------------------------------------------------------------------*
class @gtlShiftRightExpression : @gtlBinaryExpression {}
override getter @gtlShiftRightExpression eval -> @gtlData result {
  result = [[lSon eval] srOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlNotEqualExpression : Does a lSon != rSon
#---------------------------------------------------------------------------*
class @gtlNotEqualExpression : @gtlBinaryExpression {}
override getter @gtlNotEqualExpression eval -> @gtlData result {
  result = [[lSon eval] neqOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlEqualExpression : Does a lSon == rSon
#---------------------------------------------------------------------------*
class @gtlEqualExpression : @gtlBinaryExpression {}
override getter @gtlEqualExpression eval -> @gtlData result {
  result = [[lSon eval] eqOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlLowerThanExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlLowerThanExpression : @gtlBinaryExpression {}
override getter @gtlLowerThanExpression eval -> @gtlData result {
  result = [[lSon eval] ltOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlLowerOrEqualExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlLowerOrEqualExpression : @gtlBinaryExpression {}
override getter @gtlLowerOrEqualExpression eval -> @gtlData result {
  result = [[lSon eval] leOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlGreaterThanExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlGreaterThanExpression : @gtlBinaryExpression {}
override getter @gtlGreaterThanExpression eval -> @gtlData result {
  result = [[lSon eval] gtOp ![rSon eval]]
}

#---------------------------------------------------------------------------*
# @gtlGreaterOrEqualExpression : Does a lSon < rSon
#---------------------------------------------------------------------------*
class @gtlGreaterOrEqualExpression : @gtlBinaryExpression {}
override getter @gtlGreaterOrEqualExpression eval -> @gtlData result {
  result = [[lSon eval] geOp ![rSon eval]]
}

#===========================================================================*
# abstract class for a template instruction
#---------------------------------------------------------------------------*
abstract class @gtlInstruction {}

abstract method @gtlInstruction execute ?!@gtlVarMap gtlVariableMap

#---------------------------------------------------------------------------*
# let instructions
#---------------------------------------------------------------------------*
abstract class @gtlAssign : @gtlInstruction {
  @gtlVarPath    lValue
  @gtlExpression rValue
}

class @gtlLet           : @gtlAssign {}
#class @gtlLetAdd        : @gtlAssign {}
#class @gtlLetSubstract  : @gtlAssign {}
#class @gtlLetMultiply   : @gtlAssign {}
#class @gtlLetDivide     : @gtlAssign {}
#class @gtlLetModulo     : @gtlAssign {}
#class @gtlLetShiftLeft  : @gtlAssign {}
#class @gtlLetShiftRight : @gtlAssign {}
#class @gtlLetAnd        : @gtlAssign {}
#class @gtlLetOr         : @gtlAssign {}
#class @gtlLetXor        : @gtlAssign {}

override method @gtlLet execute ?!@gtlVarMap gtlVariableMap {
  [lValue setMe !?gtlVariableMap![rValue eval]]
}
  
