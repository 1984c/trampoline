/*-----------------------------------------------------------------------------
 * Interrupt specific structures
 */

#include "tpl_timers.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%

###### First we check all used interrupt sources exist
let IT_SOURCES := mapof INTERRUPT by NAME
foreach counter in HARDWARECOUNTERS do
  if not exists IT_SOURCES[counter::SOURCE] then
    error counter::SOURCE : "Interrupt source ".counter::SOURCE." does not exist"
  end if
end foreach
foreach isr in ISRS2 do
  if not exists IT_SOURCES[isr::SOURCE] then
    error isr::SOURCE : "Interrupt source ".isr::SOURCE." does not exist"
  end if
end foreach

###### Watchdog checking
let watchdog_source := ""

foreach counter in COUNTER do
  if counter::HANDLER == "watchdog" then
    let watchdog_source := counter::SOURCE
  end if
end foreach

## Warning if watchdog is disabled
if watchdog_source == "no_pit" then
    warning here : "WATCHDOG : No pit channel selected for the watchdog (given SOURCE = " .watchdog_source. "). Watchdog disabled."
elsif watchdog_source != "" & not OS::TIMINGPROTECTION then
    warning here : "WATCHDOG : OS::TIMINGPROTECTION set to false. Watchdog disabled."
end if



let counter_map   := mapof COUNTER by NAME
loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do

  ###### Get used counters and isrs
  let used_counters := emptymap
  foreach application in APPLICATION do
    if application::CORE == core_id then
      ### Used counters
      foreach counter_name in application::COUNTER do
        let counter := counter_map[counter_name::VALUE]
        let used_counters[counter::NAME] := counter
      end foreach

      ### Used ISR
    end if
  end foreach

  if OS::NUMBER_OF_CORES == 1 then
%
CONST(tpl_it_vector_entry, OS_CONST) tpl_it_table[% !INTERRUPT_COUNT::IT_TABLE_SIZE %] = {
%
  else # In multicore, we have one interrupt table for each core
%
CONST(tpl_it_vector_entry, OS_CONST) tpl_it_table_%!core_id%[% !INTERRUPT_COUNT::IT_TABLE_SIZE %] = {
%
  end if

  loop ENTRY from 0 to INTERRUPT_COUNT::IT_TABLE_SIZE - 1
  do
    let entryFound := false

    foreach interrupt in INTERRUPT do
      if ENTRY == interrupt::ID then

        if exists INTERCORE_INTERRUPT & OS::NUMBER_OF_CORES > 1 then
          ########## Intercore Interrupt Checking (Multicore only)
          foreach int_interrupt in INTERCORE_INTERRUPT do
            if int_interrupt::CORE == core_id
               & int_interrupt::SOURCE == interrupt::NAME
               & not entryFound then
              %  { (tpl_it_handler)tpl_receive_intercore_it,(void *)% !ENTRY %}%
              let entryFound := true
            end if
          end foreach
        end if

        ########## Counter Interrupt Checking
        foreach counter in used_counters do
          if counter::SOURCE == interrupt::NAME & not entryFound then
            if counter::SOURCE == "no_pit"
             | (counter::HANDLER == "watchdog" & not OS::TIMINGPROTECTION) then
              %  { (tpl_it_handler)tpl_null_it, (void *)% !ENTRY % }%
              let entryFound := true
            elsif counter::HANDLER == "watchdog" then
              %  { (tpl_it_handler)tpl_watchdog_handler, (void *)NULL }%
              let entryFound := true
            elsif OS::NUMBER_OF_CORES > 1 then
              %  { (tpl_it_handler)tpl_tick_handler_% !interrupt::NAME %_%!core_id%, (void *)NULL }%
              let entryFound := true
            else # Monocore
              %  { (tpl_it_handler)tpl_tick_handler_% !interrupt::NAME %, (void *)NULL }%
              let entryFound := true
            end if
          end if
        end foreach

        ########## ISR1 Interrupt Checking
        foreach isr in ISRS1 do
          if isr::SOURCE == interrupt::NAME & not entryFound then
            %  { (tpl_it_handler)tpl_central_interrupt_handler, (void*)% !([TASKS length] + INDEX) % }%
            let entryFound := true
          end if
        end foreach

        ########## ISR2 Interrupt Checking
        foreach isr in ISRS2 do
          if isr::SOURCE == interrupt::NAME & not entryFound then
            %  { (tpl_it_handler)tpl_central_interrupt_handler_2, (void*)% !([TASKS length] + INDEX) % }%
            let entryFound := true
          end if
        end foreach

      end if
    end foreach


    if not entryFound then
    %  { (tpl_it_handler)tpl_null_it, (void *)NULL }%
    end if
  between %,    // Vector % !ENTRY %
%
  end loop
%
  };
%
end loop

if OS::NUMBER_OF_CORES > 1 then
%
CONSTP2CONST(tpl_it_vector_entry, OS_CONST, OS_CONST) tpl_it_table[% !OS::NUMBER_OF_CORES %] = {
%
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%  tpl_it_table_%!core_id
  between%,
%
  end loop
%
};
%
end if
%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

%

template if exists tpl_external_interrupts_c

