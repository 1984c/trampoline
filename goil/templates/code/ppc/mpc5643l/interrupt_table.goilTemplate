%
#------------------------------------------------------------------------------*
# build an empty list when the list does not exist. This simplify
# further processing because existence test is not necessary

let INTERCORE_INTERRUPT := exists INTERCORE_INTERRUPT default (emptylist)
%
/*-----------------------------------------------------------------------------
 * Interrupt specific structures
 */

#include "tpl_timers.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
%

###############################################################################
#   Checks
#

###### First we check all used interrupt sources exist
let IT_SOURCES := mapof INTERRUPT by NAME
foreach counter in HARDWARECOUNTERS do
  if not exists IT_SOURCES[counter::SOURCE] then
    error counter::SOURCE : "Interrupt source ".counter::SOURCE." does not exist"
  end if
end foreach
foreach isr in ISRS do
  if not exists IT_SOURCES[isr::SOURCE] then
    error isr::SOURCE : "Interrupt source ".isr::SOURCE." does not exist"
  end if
end foreach
foreach intercore_it in INTERCORE_INTERRUPT do
  if not exists IT_SOURCES[intercore_it::SOURCE] then
    error isr::SOURCE : "Interrupt source ".isr::SOURCE." does not exist"
  end if
end foreach

###### Watchdog checking
let watchdog_source := ""

foreach counter in HARDWARECOUNTERS do
  if counter::HANDLER == "watchdog" then
    let watchdog_source := counter::SOURCE
  end if
end foreach

# Warning if watchdog is disabled
if watchdog_source == "no_pit" then
    warning here : "WATCHDOG : No pit channel selected for the watchdog (given SOURCE = " .watchdog_source. "). Watchdog disabled."
elsif watchdog_source != "" & not OS::TIMINGPROTECTION then
    warning here : "WATCHDOG : OS::TIMINGPROTECTION set to false. Watchdog disabled."
end if

###### Check ISRS are not using a wrong source
foreach isr in ISRS do
  if isr::SOURCE == "no_pit"
   | isr::SOURCE == "pit_ch0"
   | isr::SOURCE == "pit_ch1"
   | isr::SOURCE == "pit_ch2"
   | isr::SOURCE == "pit_ch3" then
    error here : "ISR " .isr::NAME. " : The uses of an hardware timer for an ISR is forbidden."
  end if
end foreach

###### Check there is not two interrupts with the same ID
let sorted_interrupt := INTERRUPT
sort sorted_interrupt by ID <

let previous_id := ""
let previous_it
foreach interrupt in sorted_interrupt do
  if [interrupt::ID string] == previous_id & previous_id != "" then
    error here : "interrupt " . interrupt::NAME . " and " . previous_it::NAME . " have the same ID (" . [interrupt::ID string] . ")"
  end if
  let previous_id := [interrupt::ID string]
  let previous_it := interrupt
end foreach

###############################################################################
#   handlers declaration
#

# Watchdog
if OS::TIMINGPROTECTION then
%extern FUNC(tpl_bool, OS_CODE) tpl_watchdog_handler(void);
%
end if

# ISR
foreach isr in ISRS do
%FUNC(tpl_bool, OS_CODE) tpl_isr_handler_% !isr::NAME %(void);
%
end foreach

# Intercore IT
foreach interrupt in INTERCORE_INTERRUPT do
%FUNC(tpl_bool, OS_CODE) tpl_intercore_handler_% !interrupt::NAME %(void);
%
end foreach

# Tick
let counter_map   := mapof COUNTER by NAME
let interrupt_map := mapof INTERRUPT by NAME

loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
  let used_interrupts := emptymap
  foreach application in APPLICATION do
    if application::CORE == core_id then
      foreach counter_name in exists application::COUNTER default (emptylist) do
        let counter := counter_map[counter_name::VALUE]
        if counter::SOURCE != "no_pit" & counter::TYPE == "HARDWARE" then
          let interrupt := interrupt_map[counter::SOURCE]
          let used_interrupts[counter::SOURCE] := interrupt
        end if
      end foreach
    end if
  end foreach

  foreach interrupt in used_interrupts do
    if OS::NUMBER_OF_CORES > 1 then
%FUNC(tpl_bool, OS_CODE) tpl_tick_handler_% !interrupt::NAME%_% !core_id %(void);
%
    else
%FUNC(tpl_bool, OS_CODE) tpl_tick_handler_% !interrupt::NAME%(void);
%
    end if
  end foreach
end loop

###############################################################################
#   tpl_it_table
#

let counter_map   := mapof COUNTER by NAME
loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do

  ###### Get used counters and isrs
  let used_counters := emptymap
  foreach application in APPLICATION do
    if application::CORE == core_id then
      ### Used counters
      foreach counter_name in exists application::COUNTER default (emptylist) do
        let counter := counter_map[counter_name::VALUE]
        let used_counters[counter::NAME] := counter
      end foreach

    end if
  end foreach

  if OS::NUMBER_OF_CORES == 1 then
%
CONST(tpl_it_vector_entry, OS_CONST) tpl_it_table[% !INTERRUPT_COUNT::IT_TABLE_SIZE %] = {
%
  else # In multicore, we have one interrupt table for each core
%
CONST(tpl_it_vector_entry, OS_CONST) tpl_it_table_%!core_id%[% !INTERRUPT_COUNT::IT_TABLE_SIZE %] = {
%
  end if

  loop ENTRY from 0 to INTERRUPT_COUNT::IT_TABLE_SIZE - 1
  do
    let entryFound := false

    foreach interrupt in INTERRUPT do
      if ENTRY == interrupt::ID then

        ########## Intercore Interrupt Checking (Multicore only)
        foreach int_interrupt in INTERCORE_INTERRUPT do
          if int_interrupt::CORE == core_id
             & int_interrupt::SOURCE == interrupt::NAME
             & not entryFound then
              %  { (tpl_it_handler)tpl_intercore_handler_% !int_interrupt::NAME %,(void *)NULL}%
            let entryFound := true
          end if
        end foreach

        ########## Counter Interrupt Checking
        foreach counter in used_counters do
          if counter::SOURCE == interrupt::NAME
           & counter::TYPE == "HARDWARE"
           & not entryFound then
            if counter::SOURCE == "no_pit"
             | (counter::HANDLER == "watchdog" & not OS::TIMINGPROTECTION) then
              %  { (tpl_it_handler)tpl_null_it, (void *)% !ENTRY % }%
              let entryFound := true
            elsif counter::HANDLER == "watchdog" then
              %  { (tpl_it_handler)tpl_watchdog_handler, (void *)NULL }%
              let entryFound := true
            elsif OS::NUMBER_OF_CORES > 1 then
              %  { (tpl_it_handler)tpl_tick_handler_% !interrupt::NAME %_%!core_id%, (void *)NULL }%
              let entryFound := true
            else # Monocore
              %  { (tpl_it_handler)tpl_tick_handler_% !interrupt::NAME %, (void *)NULL }%
              let entryFound := true
            end if
          end if
        end foreach

        ########## ISR Interrupt Checking
        foreach isr in ISRS do
          foreach application in APPLICATION do
            if application::CORE == core_id then
              foreach app_isr in exists application::ISR default (emptylist) do
                if app_isr::VALUE == isr::NAME
                 & isr::SOURCE == interrupt::NAME
                 & not entryFound then
%  { (tpl_it_handler)tpl_isr_handler_%!isr::NAME%, (void*)NULL }%
                  let entryFound := true
                end if
              end foreach
            end if
          end foreach
        end foreach

      end if
    end foreach


    if not entryFound then
    %  { (tpl_it_handler)tpl_null_it, (void *)NULL }%
    end if
  between %,    // Vector % !ENTRY %
%
  end loop
%
  };
%
end loop

###############################################################################
#   tpl_it_table pointer (multicore only)
#

if OS::NUMBER_OF_CORES > 1 then
%
CONSTP2CONST(tpl_it_vector_entry, OS_CONST, OS_CONST) tpl_it_table[% !OS::NUMBER_OF_CORES %] = {
%
  loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%  tpl_it_table_%!core_id
  between%,
%
  end loop
%
};
%
end if
%
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

%

template if exists tpl_external_interrupts_c

