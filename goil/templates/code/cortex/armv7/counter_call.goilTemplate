#include "tpl_os_kernel.h"          /* tpl_schedule */
#include "tpl_os_timeobj_kernel.h"  /* tpl_counter_tick */
#include "tpl_machine_interface.h"  /* tpl_switch_context_from_it */

#define OS_START_SEC_VAR_32BIT
#include "tpl_memmap.h"
volatile VAR(uint32, OS_VAR) tpl_time_counter = 0;
#define OS_STOP_SEC_VAR_32BIT
#include "tpl_memmap.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"
%

foreach objList in objForIRQ do
  let counterList := emptylist
  foreach obj in objList do
    if obj::KIND == "COUNTER" then
      let counterList += obj
    end if
    if [counterList length] > 0 then
    %
FUNC(tpl_bool, OS_CODE) tpl_tick_% !obj::NAME %(void)
{
%
      foreach elt in counterList do
        %  tpl_counter_tick(&% !elt::NAME %_counter_desc);
%
        if elt::SOURCE == "SysTick" then
        %  tpl_time_counter++;
%
        end if
      end foreach
    if OS::NUMBER_OF_CORES == 1 then
%
  if (tpl_kern.need_schedule == TRUE)
  {
    tpl_schedule_from_running();
    LOCAL_SWITCH_CONTEXT()
  }
%
    else
%
  GET_CURRENT_CORE_ID(core_id)
  tpl_multi_schedule();
  tpl_dispatch_context_switch();
  if (TPL_KERN(core_id).need_switch != NO_NEED_SWITCH)
  {
    LOCAL_SWITCH_CONTEXT()
  }
%
    end if
%
  return TRUE;
}
%
    end if
  end foreach
end foreach

%
#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"
