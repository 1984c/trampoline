%#------------------------------------------------------------------------------*
# Target specific initializations
# build the maps for IRQ
#
let objForIRQ := emptymap

# Map ISR into objForIRQ
foreach isr in ISR do
  let key := isr::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := emptylist
  end if
  let isr::KIND := "ISR"
  let objForIRQ[key] += isr
end foreach

# Map COUNTER into objForIRQ
foreach cnt in COUNTER do
  let key := cnt::SOURCE
  if not exists objForIRQ[key] then
    let objForIRQ[key] := emptylist
  end if
  let cnt::KIND := "COUNTER"
  let objForIRQ[key] += cnt
end foreach

let INTERRUPTMAP := mapof INTERRUPT by NAME
#------------------------------------------------------------------------------*
%/**
 * @file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE %
 *
 * @section descr File description
 *
 * 
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */

#include "tpl_assembler.h"
#include "tpl_asm_definitions.h"
#include "tpl_os_kernel_stack.h"
#include "tpl_os_process_stack.h"

.syntax unified
.thumb

.section .osVar CAR_ACCESS_RIGHT

.equ  NO_NEED_SWITCH_NOR_SCHEDULE , 0
.equ  NO_NEED_SWITCH , 0
.equ  NEED_SWITCH , 1
.equ  NEED_SAVE , 2

#define OS_START_SEC_CODE
#include "tpl_as_memmap.h"

.extern nested_kernel_entrance_counter
.extern tpl_kern
.extern tpl_dispatch_table

/*
 * Second stage category 2 interrupt handler (which means only IRQ on
 * this architecture, FIQ are category 1 interrupts)
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We take care to not alter callee saved registers
 * which are all except r0-r3 (EABI convention).
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * We do not use r3 because it is used to give the service number
 * in a system call. After dispatching, r3 can be altered.
 *
 * This exception to EABI conventions is specific to system call
 * mechanism.
 */

/*
 ---------------
 | WITHOUT FPU |
        ---------------
 STACK BEFORE SYSTEM CALL, BEFORE PUSHING CONTEXT

*          |---------------------------|
*          |                           |
* SP    -> |---------------------------|

  STACK AFTER PUSHING CONTEXT

*          |---------------------------|
*          |                           | |
*          |---------------------------| |<- Pre-IRQ Top of Stack
*          | {aligner}                 | |
* SP+32 -> |---------------------------|
*          | xPSR                      |
* SP+28 -> |---------------------------|
*          | PC                        |
* SP+24 -> |---------------------------|
*          | LR return address         |
* SP+20 -> |---------------------------|
*          | R12                       |
* SP+16 -> |---------------------------|
*          | R3 service number         |
* SP+12 -> |---------------------------|
*          | R2                        |
* SP+8  -> |---------------------------|
*          | R1                        |
* SP+4  -> |---------------------------|
*          | R0                        |
* SP    -> |---------------------------| <- IRQ Top of stack

        ---------------
 | WITH FPU    |
        ---------------
 STACK BEFORE SYSTEM CALL, BEFORE PUSHING CONTEXT

*          |---------------------------|
*          |                           |
* SP    -> |---------------------------|

  STACK AFTER PUSHING CONTEXT

* SP+32 -> |---------------------------|
*          | xPSR                      |
* SP+28 -> |---------------------------|
*          | PC                        |
* SP+24 -> |---------------------------|
*          | LR return address         |
* SP+20 -> |---------------------------|
*          | R12                       |
* SP+16 -> |---------------------------|
*          | R3 service number         |
* SP+12 -> |---------------------------|
*          | R2                        |
* SP+8  -> |---------------------------|
*          | R1                        |
* SP+4  -> |---------------------------|
*          | R0                        |
* SP    -> |---------------------------| <- IRQ Top of stack

*/

.section .osCode CODE_ACCESS_RIGHT

/*******************************************************************************
 *
 *******************************************************************************/
tpl_enter_kernel:
 #if WITH_MEMORY_PROTECTION == YES
 /*
  * Switch to kernel memory protection scheme
  */
  push {lr}
  bl tpl_kernel_mp
  pop {lr}
 #endif
 /* 
  * Manage reentrance of kernel
  * Increment nested_kernel_entrance_counter
  */
  ldr r12, =nested_kernel_entrance_counter
  ldr r4, [r12]
  add r4, r4, #1
  str r4, [r12]
 /* 
  * NA: Switch to the kernel stack
  * Automatic (configuration) for the Cortex-M4
  */

 /*
  * NA: Make space on the stack to call C functions
  * Automatic for the Cortex-M4
  */
tpl_enter_kernel_exit: 
  bx lr

/*******************************************************************************
 *
 *******************************************************************************/
tpl_leave_kernel:
 /*
  * NA: Restore saved registers in the system stack
  * Automatic for the Cortex-M4
  */
 
 /* 
  * Manage reentrance of kernel
  * Decrement nested_kernel_entrance_counter
  *
  * We update kernel reentrance counter while registers are freely
  * usable and as we know we won t enter in kernel again (IRQ locked and
  * no SWI can occur)
  *
  * NA: If it reaches 0, the process stack is restored
  * Automatic for the Cortex-M4
  */
  ldr r12, =nested_kernel_entrance_counter
  ldr r4, [r12]
  sub r4, r4, #1
  str r4, [r12]
 
 #if WITH_MEMORY_PROTECTION == YES
 /*
  * Switch to user memory protection scheme
  */
  push {lr}
  bl tpl_user_mp
  pop {lr}
 #endif
tpl_leave_kernel_exit:
 bx lr

%

foreach objList in objForIRQ do
  let src := KEY
  let handlerAck := false
  foreach obj in objList
    before
%

%
    do
      let handlerName := obj::NAME
      let handlerSource := obj::SOURCE
      let handlerIRQ := handlerSource."_Handler"
      if INTERRUPTMAP[src]::ACK then
        let handlerAck := true
      end if
      if obj::KIND == "ISR" then
# ISR 1
        if obj::CATEGORY == 1 then
%
 /******************************************************************************
 * IRQ Handler for ISR % !obj::NAME % with source vector % !obj::SOURCE % category % !obj::CATEGORY %
 *******************************************************************************/
%
          template if exists handler_body
        else
# ISR2
          if obj::CATEGORY == 2 then
%
 /******************************************************************************
 * IRQ Handler for ISR % !obj::NAME % with source vector % !obj::SOURCE % category % !obj::CATEGORY %
 *******************************************************************************/
%
            template if exists handler_body
          else
            error obj::NAME : "This interrupt category ".obj::CATEGORY." does not exist"
          end if
        end if
      else
# COUNTER
        if obj::KIND == "COUNTER" then
%
 /******************************************************************************
 * IRQ Handler for COUNTER % !obj::NAME % with source vector % !obj::SOURCE %
 *******************************************************************************/
%
          template if exists handler_body
        else
          error obj::NAME : "This kind of object ".obj::KIND." does not exist"
        end if
      end if
    after
%
%
  end foreach
end foreach

%
#define OS_STOP_SEC_CODE
#include "tpl_as_memmap.h"

#define OS_START_LTORG
#include "tpl_as_memmap.h"
#define OS_STOP_LTORG
#include "tpl_as_memmap.h"

.end

/* End of file tpl_second_stage_irq.% !EXTENSIONSECONDSTAGE % */
