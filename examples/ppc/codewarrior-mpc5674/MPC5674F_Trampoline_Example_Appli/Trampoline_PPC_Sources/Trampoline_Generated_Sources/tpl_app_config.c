/**
 * @file tpl_app_config.c
 *
 * @section desc File description
 *
 * OS data structure generated from application test
 * Automatically generated by goil on Wed Apr 06 18:56:06 2016
 * from root OIL file Trampoline_Application.oil
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include "tpl_app_config.h"

#include "tpl_os_internal_types.h"
#include "tpl_machine.h"
#include "tpl_os_interrupt.h"
#include "tpl_os_interrupt_kernel.h"
#include "tpl_os_alarm_kernel.h"
#include "tpl_os_alarm.h"
#include "tpl_os_resource_kernel.h"
#include "tpl_os_resource.h"
#include "tpl_os_event_kernel.h"
#include "tpl_os_event.h"
#include "tpl_os_action.h"
#include "tpl_os_kernel.h"
#include "tpl_os_definitions.h"


/*=============================================================================
 * Application Modes tables for tasks, alarms and schedule tables
 * Application Modes masks are as follow:
 * std = 1
 */

CONST(tpl_application_mode, OS_CONST) std = 0; /* mask = 1 */
CONST(tpl_application_mode, OS_CONST) OSDEFAULTAPPMODE = 0;
CONST(tpl_appmode_mask, OS_CONST) tpl_task_app_mode[TASK_COUNT] = {
  0 /* task solonelyfriend :  */ ,
  1 /* task iamsolonely : std */ ,
  0 /* task gogo :  */ 
};

CONST(tpl_appmode_mask, OS_CONST) tpl_alarm_app_mode[ALARM_COUNT] = {
  1 /* alarm rungogo : std */ 
};

#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/*=============================================================================
 * Declaration of processes IDs
 */

/* Task solonelyfriend identifier */
#define solonelyfriend_id 0
CONST(TaskType, AUTOMATIC) solonelyfriend = solonelyfriend_id;

/* Task iamsolonely identifier */
#define iamsolonely_id 1
CONST(TaskType, AUTOMATIC) iamsolonely = iamsolonely_id;

/* Task gogo identifier */
#define gogo_id 2
CONST(TaskType, AUTOMATIC) gogo = gogo_id;

/* ISR isr_sw_it7 identifier */
#define isr_sw_it7_id 3
/*=============================================================================
 * Declaration of Alarm IDs
 */

/* Alarm rungogo identifier */
#define rungogo_id 0
CONST(AlarmType, AUTOMATIC) rungogo = rungogo_id;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_resource, AUTOMATIC, OS_APPL_DATA)
tpl_resource_table[RESOURCE_COUNT] = {
  &res_sched_rez_desc  
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Counters related defines and structures
 */
/*-----------------------------------------------------------------------------
 * Counter SystemCounter descriptor
 */

#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_tick, OS_CONST) OSTICKSPERBASE = 1;
CONST(tpl_tick, OS_CONST) OSMAXALLOWEDVALUE = 32767;
CONST(tpl_tick, OS_CONST) OSMINCYCLE = 1;

#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_counter, OS_VAR) SystemCounter_counter_desc = {
  /* ticks per base       */  1,
  /* max allowed value    */  32767,
  /* minimum cycle        */  1,
  /* current tick         */  0,
  /* current date         */  0,
#if WITH_OSAPPLICATION == YES
    /* OS Application id    */  
#endif
    /* first alarm          */  NULL_PTR,
    /* next alarm to raise  */  NULL_PTR
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#include "tpl_os_kernel.h"          /* tpl_schedule */
#include "tpl_os_timeobj_kernel.h"  /* tpl_counter_tick */
#include "tpl_machine_interface.h"  /* tpl_switch_context_from_it */

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_CODE) AckPIT_0(void);

FUNC(void, OS_CODE) tpl_tick_PIT_0()
{
  tpl_counter_tick(&SystemCounter_counter_desc);

  AckPIT_0();
  if (tpl_kern.need_schedule)
  {
    tpl_schedule_from_running();
  }
}

#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

/*=============================================================================
 * Descriptor(s) of the idle task(s)
 */
/*-----------------------------------------------------------------------------
 * Task IDLE_TASK descriptor
 */
#define OS_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * Task IDLE_TASK function prototype
 */

FUNC(void, OS_APPL_CODE) idle_function(void);
#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task IDLE_TASK stack
 */
#define APP_Task_IDLE_TASK_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) IDLE_TASK_stack_zone[IDLE_STACK_SIZE/sizeof(tpl_stack_word)];
#define APP_Task_IDLE_TASK_STOP_SEC_STACK
#include "tpl_memmap.h"

#define IDLE_TASK_STACK {IDLE_TASK_stack_zone, IDLE_STACK_SIZE}

/*
 * Task IDLE_TASK context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(ppc_integer_context, OS_VAR) IDLE_TASK_int_context;
#define IDLE_TASK_CONTEXT { &IDLE_TASK_int_context }
#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task IDLE_TASK
 */
CONST(tpl_proc_static, OS_CONST) IDLE_TASK_task_stat_desc = {
  /* context                  */  IDLE_TASK_CONTEXT,
  /* stack                    */  IDLE_TASK_STACK,
  /* entry point (function)   */  idle_function,
  /* internal ressource       */  NULL,
  /* task id                  */  IDLE_TASK_ID,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  0,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task IDLE_TASK
 */
VAR(tpl_proc, OS_VAR) IDLE_TASK_task_desc = {
  /* resources                      */  NULL,
#if WITH_OSAPPLICATION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_OSAPPLICATION */
  /* activate count                 */  0,
  /* task priority                  */  0,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Task related defines and structures
 */
/*-----------------------------------------------------------------------------
 * Task solonelyfriend descriptor
 */
#define APP_Task_solonelyfriend_START_SEC_CODE

#include "tpl_memmap.h"
/*
 * Task solonelyfriend function prototype
 */

FUNC(void, OS_APPL_CODE) solonelyfriend_function(void);
#define APP_Task_solonelyfriend_STOP_SEC_CODE

#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task solonelyfriend stack
 */
#define APP_Task_solonelyfriend_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) solonelyfriend_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_solonelyfriend_STOP_SEC_STACK
#include "tpl_memmap.h"

#define solonelyfriend_STACK {solonelyfriend_stack_zone, 500}

/*
 * Task solonelyfriend context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(ppc_integer_context, OS_VAR) solonelyfriend_int_context;
#define solonelyfriend_CONTEXT { &solonelyfriend_int_context }
#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task solonelyfriend
 */
CONST(tpl_proc_static, OS_CONST) solonelyfriend_task_stat_desc = {
  /* context                  */  solonelyfriend_CONTEXT,
  /* stack                    */  solonelyfriend_STACK,
  /* entry point (function)   */  solonelyfriend_function,
  /* internal ressource       */  NULL,
  /* task id                  */  solonelyfriend_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task solonelyfriend
 */
VAR(tpl_proc, OS_VAR) solonelyfriend_task_desc = {
  /* resources                      */  NULL,
#if WITH_OSAPPLICATION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_OSAPPLICATION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task iamsolonely descriptor
 */
#define APP_Task_iamsolonely_START_SEC_CODE

#include "tpl_memmap.h"
/*
 * Task iamsolonely function prototype
 */

FUNC(void, OS_APPL_CODE) iamsolonely_function(void);
#define APP_Task_iamsolonely_STOP_SEC_CODE

#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task iamsolonely stack
 */
#define APP_Task_iamsolonely_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) iamsolonely_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_iamsolonely_STOP_SEC_STACK
#include "tpl_memmap.h"

#define iamsolonely_STACK {iamsolonely_stack_zone, 500}

/*
 * Task iamsolonely context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(ppc_integer_context, OS_VAR) iamsolonely_int_context;
#define iamsolonely_CONTEXT { &iamsolonely_int_context }
#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task iamsolonely
 */
CONST(tpl_proc_static, OS_CONST) iamsolonely_task_stat_desc = {
  /* context                  */  iamsolonely_CONTEXT,
  /* stack                    */  iamsolonely_STACK,
  /* entry point (function)   */  iamsolonely_function,
  /* internal ressource       */  NULL,
  /* task id                  */  iamsolonely_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  1,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task iamsolonely
 */
VAR(tpl_proc, OS_VAR) iamsolonely_task_desc = {
  /* resources                      */  NULL,
#if WITH_OSAPPLICATION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_OSAPPLICATION */
  /* activate count                 */  0,
  /* task priority                  */  1,
  /* task state                     */  AUTOSTART
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Task gogo descriptor
 */
#define APP_Task_gogo_START_SEC_CODE

#include "tpl_memmap.h"
/*
 * Task gogo function prototype
 */

FUNC(void, OS_APPL_CODE) gogo_function(void);
#define APP_Task_gogo_STOP_SEC_CODE

#include "tpl_memmap.h"

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * Task gogo stack
 */
#define APP_Task_gogo_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) gogo_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_Task_gogo_STOP_SEC_STACK
#include "tpl_memmap.h"

#define gogo_STACK {gogo_stack_zone, 500}

/*
 * Task gogo context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(ppc_integer_context, OS_VAR) gogo_int_context;
#define gogo_CONTEXT { &gogo_int_context }
#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"


#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

/*
  No timing protection
 */

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of task gogo
 */
CONST(tpl_proc_static, OS_CONST) gogo_task_stat_desc = {
  /* context                  */  gogo_CONTEXT,
  /* stack                    */  gogo_STACK,
  /* entry point (function)   */  gogo_function,
  /* internal ressource       */  NULL,
  /* task id                  */  gogo_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif
  /* task base priority       */  2,
  /* max activation count     */  1,
  /* task type                */  TASK_BASIC,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of task gogo
 */
VAR(tpl_proc, OS_VAR) gogo_task_desc = {
  /* resources                      */  NULL,
#if WITH_OSAPPLICATION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_OSAPPLICATION */
  /* activate count                 */  0,
  /* task priority                  */  2,
  /* task state                     */  SUSPENDED
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of ISR2 related defines and structures
 */
/*-----------------------------------------------------------------------------
 * ISR isr_sw_it7 descriptor
 */
#define APP_ISR_isr_sw_it7_START_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR isr_sw_it7 function prototype
 */
FUNC(void, OS_APPL_CODE) isr_sw_it7_function(void);
#define APP_ISR_isr_sw_it7_STOP_SEC_CODE
#include "tpl_memmap.h"
/*
 * ISR isr_sw_it7 ACK function prototype
 */
FUNC(void, OS_APPL_CODE) isr_sw_it7_ack(void);
/*
 * ISR isr_sw_it7 handler
 */
FUNC(void, OS_APPL_CODE) isr_sw_it7_handler()
{
  tpl_central_interrupt_handler(isr_sw_it7_id);
  isr_sw_it7_ack();
} 

/*-----------------------------------------------------------------------------
 * Target specific structures
 */
/*
 * ISR isr_sw_it7 stack
 */
#define APP_ISR_isr_sw_it7_START_SEC_STACK
#include "tpl_memmap.h"
VAR(tpl_stack_word, OS_APPL_DATA) isr_sw_it7_stack_zone[500/sizeof(tpl_stack_word)];
#define APP_ISR_isr_sw_it7_STOP_SEC_STACK
#include "tpl_memmap.h"

#define isr_sw_it7_STACK {isr_sw_it7_stack_zone, 500}

/*
 * ISR isr_sw_it7 context
 */
#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"
VAR(ppc_integer_context, OS_VAR) isr_sw_it7_int_context;
#define isr_sw_it7_CONTEXT { &isr_sw_it7_int_context }
#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"


/*
  No timing protection
 */

#if WITH_AUTOSAR_TIMING_PROTECTION == YES
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
#endif

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*
 * Static descriptor of ISR isr_sw_it7
 */
CONST(tpl_proc_static, OS_CONST) isr_sw_it7_isr_stat_desc = {
  /* context                  */  isr_sw_it7_CONTEXT,
  /* stack                    */  isr_sw_it7_STACK,
  /* entry point (function)   */  isr_sw_it7_function,
  /* internal ressource       */  NULL,
  /* ISR id                   */  isr_sw_it7_id,
#if WITH_OSAPPLICATION == YES
  /* OS application id        */  
#endif

  /* ISR base priority       */  4,
  /* ISR activation count     */  1,
  /* ISR type                */  IS_ROUTINE,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* pointer to the timing
     protection descriptor    */  $TIMING_PROT_REF$
#endif
};

CONST(tpl_isr_static, OS_CONST) isr_sw_it7_isr_helper = {
  /* helper */ NULL,
  /* next */   NULL,
  /* id */     isr_sw_it7_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"
/*
 * Dynamic descriptor of ISR isr_sw_it7
 */
VAR(tpl_proc, OS_VAR) isr_sw_it7_isr_desc = {
  /* resources                      */  NULL,
#if WITH_OSAPPLICATION == YES
  /* if > 0 the process is trusted  */  0,    
#endif /* WITH_OSAPPLICATION */
  /* activate count                 */  0,
  /* ISR priority                   */  4,
  /* ISR state                      */  SUSPENDED,
#if WITH_AUTOSAR_TIMING_PROTECTION == YES
  /* activation allowed             */  ,TRUE
#endif
};
#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONST(tpl_it_vector_entry, OS_CONST) tpl_it_table[350] = {
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)isr_sw_it7_handler, (void*)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_tick_PIT_0, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL },
  { (tpl_it_handler)tpl_null_it, (void *)NULL }
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
/*=============================================================================
 * Definition and initialization of process tables (tasks and isrs)
 */
CONSTP2CONST(tpl_proc_static, AUTOMATIC, OS_APPL_DATA)
tpl_stat_proc_table[TASK_COUNT+ISR_COUNT+1] = {
  &solonelyfriend_task_stat_desc,
  &iamsolonely_task_stat_desc,
  &gogo_task_stat_desc,
  &isr_sw_it7_isr_stat_desc,
  &IDLE_TASK_task_stat_desc
};

CONSTP2VAR(tpl_proc, AUTOMATIC, OS_APPL_DATA)
tpl_dyn_proc_table[TASK_COUNT+ISR_COUNT+1] = {
  &solonelyfriend_task_desc,
  &iamsolonely_task_desc,
  &gogo_task_desc,
  &isr_sw_it7_isr_desc,
  &IDLE_TASK_task_desc
};

CONSTP2CONST(tpl_isr_static, AUTOMATIC, OS_APPL_DATA)
tpl_isr_stat_table[ISR_COUNT] = {
  &isr_sw_it7_isr_helper
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/*=============================================================================
 * Definition and initialization of Alarm related structures
 */
/*-----------------------------------------------------------------------------
 * Alarm rungogo descriptor
 *
 * This alarm does the activation of task gogo
 */


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_task_activation_action, OS_CONST) rungogo_action = {
  {
    /* action function  */  tpl_action_activate_task
  },
  /* task id            */  gogo_id
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
 
#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

CONST(tpl_alarm_static, OS_CONST) rungogo_static = {
  {
    /* pointer to counter           */  &SystemCounter_counter_desc,
    /* pointer to the expiration    */  tpl_raise_alarm
#if (WITH_TRACE == YES)
    /* id of the alarm for tracing  */  , rungogo_id
#endif
#if WITH_OSAPPLICATION == YES
    /* OS application id            */  , 
#endif
  },
  /* action of the alarm  */  (tpl_action *)&rungogo_action
};

#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_time_obj, OS_VAR) rungogo_alarm_desc = {
    /* pointer to the static part   */  (tpl_time_obj_static *)&rungogo_static,
    /* next alarm                   */  NULL,
    /* prev alarm                   */  NULL,
    /* cycle                        */  1,
    /* date                         */  1,
    /* State of the alarm           */  ALARM_AUTOSTART
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"


#define OS_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2VAR(tpl_time_obj, AUTOMATIC, OS_APPL_DATA)
  tpl_alarm_table[ALARM_COUNT] = {
  &rungogo_alarm_desc
};
#define OS_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"

/*=============================================================================
 * Declaration of flags functions
 */
/* $FLAGSFUNCTIONS$ */

/*=============================================================================
 * Definition and initialization of Ready List structures
 */
#define OS_START_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

VAR(tpl_heap_entry, OS_VAR) tpl_ready_list[8];
VAR(tpl_rank_count, OS_VAR) tpl_tail_for_prio[6] = {
  0,
  0,
  0,
  0,
  0,
  0
};

#define OS_STOP_SEC_VAR_UNSPECIFIED
#include "tpl_memmap.h"

/**
 * @internal
 *
 * tpl_kern gather informations on the current executing object and
 * the previous one
 */
VAR(tpl_kern_state, OS_VAR) tpl_kern =
{
  NULL,                      /* no running task static descriptor   */
  &IDLE_TASK_task_stat_desc, /* elected task to run is idle task    */
  NULL,                      /* no running task dynamic descriptor  */
  &IDLE_TASK_task_desc,      /* elected task to run is idle task    */
  INVALID_PROC_ID,           /* no running task so no ID            */
  INVALID_PROC_ID,           /* idle task has no ID                 */
  NO_NEED_SWITCH,            /* no context switch needed at start   */
  FALSE,                     /* no schedule needed at start         */
#if WITH_MEMORY_PROTECTION == YES
  1,                         /* at early system startup, we run in  */
                             /*  kernel mode, so in trusted mode    */
#endif /* WITH_MEMORY_PROTECTION */
};

#define API_START_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"
CONSTP2CONST(char, AUTOMATIC, OS_APPL_DATA) proc_name_table[TASK_COUNT + ISR_COUNT + 1] = {

  "solonelyfriend",
  "iamsolonely",
  "gogo",
  "isr_sw_it7",
  "*idle*"
};
#define API_STOP_SEC_CONST_UNSPECIFIED
#include "tpl_memmap.h"


/* End of file tpl_app_config.c */
