/**
 * @file tpl_invoque.S
 *
 * @section descr File description
 *
 * System call user level invoque API.
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */
#include "tpl_os_application_def.h"
#include "tpl_service_ids.h"

#if WITH_SYSTEM_CALL == NO
#error "This file should not be part of your project since WITH_SYSTEM_CALL is not defined"
#endif


#if WITH_MEMMAP == NO

#endif /* WITH_MEMMAP == NO */

#define API_START_SEC_CODE
#include "tpl_as_memmap.h"

	.syntax unified
	.thumb
	.extern nested_kernel_entrance_counter

	/* 
	 * Service GetActiveApplicationMode
	 */
	.global GetActiveApplicationMode
	.type   GetActiveApplicationMode, %function
GetActiveApplicationMode:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetActiveApplicationMode_direct_call
	/* Exception call to the service : use SVC exception */
GetActiveApplicationMode_exception_call:
	movs r3,#OSServiceId_GetActiveApplicationMode
	svc #OSServiceId_GetActiveApplicationMode
	b GetActiveApplicationMode_exit_call
	/* Procedural call to the service */
GetActiveApplicationMode_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetActiveApplicationMode<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
GetActiveApplicationMode_exit_call:
	bx lr
	/* 
	 * Service StartOS
	 */
	.global tpl_start_os
	.type   tpl_start_os, %function
tpl_start_os:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq StartOS_direct_call
	/* Exception call to the service : use SVC exception */
StartOS_exception_call:
	movs r3,#OSServiceId_StartOS
	svc #OSServiceId_StartOS
	b StartOS_exit_call
	/* Procedural call to the service */
StartOS_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_StartOS<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
StartOS_exit_call:
	bx lr
	/* 
	 * Service ShutdownOS
	 */
	.global ShutdownOS
	.type   ShutdownOS, %function
ShutdownOS:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ShutdownOS_direct_call
	/* Exception call to the service : use SVC exception */
ShutdownOS_exception_call:
	movs r3,#OSServiceId_ShutdownOS
	svc #OSServiceId_ShutdownOS
	b ShutdownOS_exit_call
	/* Procedural call to the service */
ShutdownOS_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ShutdownOS<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
ShutdownOS_exit_call:
	bx lr
	/* 
	 * Service EnableAllInterrupts
	 */
	.global EnableAllInterrupts
	.type   EnableAllInterrupts, %function
EnableAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq EnableAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
EnableAllInterrupts_exception_call:
	movs r3,#OSServiceId_EnableAllInterrupts
	svc #OSServiceId_EnableAllInterrupts
	b EnableAllInterrupts_exit_call
	/* Procedural call to the service */
EnableAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_EnableAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
EnableAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service DisableAllInterrupts
	 */
	.global DisableAllInterrupts
	.type   DisableAllInterrupts, %function
DisableAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq DisableAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
DisableAllInterrupts_exception_call:
	movs r3,#OSServiceId_DisableAllInterrupts
	svc #OSServiceId_DisableAllInterrupts
	b DisableAllInterrupts_exit_call
	/* Procedural call to the service */
DisableAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_DisableAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
DisableAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service ResumeAllInterrupts
	 */
	.global ResumeAllInterrupts
	.type   ResumeAllInterrupts, %function
ResumeAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ResumeAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
ResumeAllInterrupts_exception_call:
	movs r3,#OSServiceId_ResumeAllInterrupts
	svc #OSServiceId_ResumeAllInterrupts
	b ResumeAllInterrupts_exit_call
	/* Procedural call to the service */
ResumeAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ResumeAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
ResumeAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service SuspendAllInterrupts
	 */
	.global SuspendAllInterrupts
	.type   SuspendAllInterrupts, %function
SuspendAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SuspendAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
SuspendAllInterrupts_exception_call:
	movs r3,#OSServiceId_SuspendAllInterrupts
	svc #OSServiceId_SuspendAllInterrupts
	b SuspendAllInterrupts_exit_call
	/* Procedural call to the service */
SuspendAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SuspendAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
SuspendAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service ResumeOSInterrupts
	 */
	.global ResumeOSInterrupts
	.type   ResumeOSInterrupts, %function
ResumeOSInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ResumeOSInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
ResumeOSInterrupts_exception_call:
	movs r3,#OSServiceId_ResumeOSInterrupts
	svc #OSServiceId_ResumeOSInterrupts
	b ResumeOSInterrupts_exit_call
	/* Procedural call to the service */
ResumeOSInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ResumeOSInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
ResumeOSInterrupts_exit_call:
	bx lr
	/* 
	 * Service SuspendOSInterrupts
	 */
	.global SuspendOSInterrupts
	.type   SuspendOSInterrupts, %function
SuspendOSInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SuspendOSInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
SuspendOSInterrupts_exception_call:
	movs r3,#OSServiceId_SuspendOSInterrupts
	svc #OSServiceId_SuspendOSInterrupts
	b SuspendOSInterrupts_exit_call
	/* Procedural call to the service */
SuspendOSInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SuspendOSInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
SuspendOSInterrupts_exit_call:
	bx lr
	/* 
	 * Service CallTerminateISR2
	 */
	.global CallTerminateISR2
	.type   CallTerminateISR2, %function
CallTerminateISR2:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq CallTerminateISR2_direct_call
	/* Exception call to the service : use SVC exception */
CallTerminateISR2_exception_call:
	movs r3,#OSServiceId_CallTerminateISR2
	svc #OSServiceId_CallTerminateISR2
	b CallTerminateISR2_exit_call
	/* Procedural call to the service */
CallTerminateISR2_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_CallTerminateISR2<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
CallTerminateISR2_exit_call:
	bx lr
	/* 
	 * Service ActivateTask
	 */
	.global ActivateTask
	.type   ActivateTask, %function
ActivateTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ActivateTask_direct_call
	/* Exception call to the service : use SVC exception */
ActivateTask_exception_call:
	movs r3,#OSServiceId_ActivateTask
	svc #OSServiceId_ActivateTask
	b ActivateTask_exit_call
	/* Procedural call to the service */
ActivateTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ActivateTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
ActivateTask_exit_call:
	bx lr
	/* 
	 * Service TerminateTask
	 */
	.global TerminateTask
	.type   TerminateTask, %function
TerminateTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq TerminateTask_direct_call
	/* Exception call to the service : use SVC exception */
TerminateTask_exception_call:
	movs r3,#OSServiceId_TerminateTask
	svc #OSServiceId_TerminateTask
	b TerminateTask_exit_call
	/* Procedural call to the service */
TerminateTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_TerminateTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
TerminateTask_exit_call:
	bx lr
	/* 
	 * Service ChainTask
	 */
	.global ChainTask
	.type   ChainTask, %function
ChainTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ChainTask_direct_call
	/* Exception call to the service : use SVC exception */
ChainTask_exception_call:
	movs r3,#OSServiceId_ChainTask
	svc #OSServiceId_ChainTask
	b ChainTask_exit_call
	/* Procedural call to the service */
ChainTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ChainTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
ChainTask_exit_call:
	bx lr
	/* 
	 * Service Schedule
	 */
	.global Schedule
	.type   Schedule, %function
Schedule:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq Schedule_direct_call
	/* Exception call to the service : use SVC exception */
Schedule_exception_call:
	movs r3,#OSServiceId_Schedule
	svc #OSServiceId_Schedule
	b Schedule_exit_call
	/* Procedural call to the service */
Schedule_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_Schedule<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
Schedule_exit_call:
	bx lr
	/* 
	 * Service GetTaskID
	 */
	.global GetTaskID
	.type   GetTaskID, %function
GetTaskID:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetTaskID_direct_call
	/* Exception call to the service : use SVC exception */
GetTaskID_exception_call:
	movs r3,#OSServiceId_GetTaskID
	svc #OSServiceId_GetTaskID
	b GetTaskID_exit_call
	/* Procedural call to the service */
GetTaskID_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetTaskID<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
GetTaskID_exit_call:
	bx lr
	/* 
	 * Service GetTaskState
	 */
	.global GetTaskState
	.type   GetTaskState, %function
GetTaskState:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetTaskState_direct_call
	/* Exception call to the service : use SVC exception */
GetTaskState_exception_call:
	movs r3,#OSServiceId_GetTaskState
	svc #OSServiceId_GetTaskState
	b GetTaskState_exit_call
	/* Procedural call to the service */
GetTaskState_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetTaskState<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
GetTaskState_exit_call:
	bx lr
	/* 
	 * Service CallTerminateTask
	 */
	.global CallTerminateTask
	.type   CallTerminateTask, %function
CallTerminateTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq CallTerminateTask_direct_call
	/* Exception call to the service : use SVC exception */
CallTerminateTask_exception_call:
	movs r3,#OSServiceId_CallTerminateTask
	svc #OSServiceId_CallTerminateTask
	b CallTerminateTask_exit_call
	/* Procedural call to the service */
CallTerminateTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_CallTerminateTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
CallTerminateTask_exit_call:
	bx lr
	/* 
	 * Service GetResource
	 */
	.global GetResource
	.type   GetResource, %function
GetResource:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetResource_direct_call
	/* Exception call to the service : use SVC exception */
GetResource_exception_call:
	movs r3,#OSServiceId_GetResource
	svc #OSServiceId_GetResource
	b GetResource_exit_call
	/* Procedural call to the service */
GetResource_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetResource<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
GetResource_exit_call:
	bx lr
	/* 
	 * Service ReleaseResource
	 */
	.global ReleaseResource
	.type   ReleaseResource, %function
ReleaseResource:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ReleaseResource_direct_call
	/* Exception call to the service : use SVC exception */
ReleaseResource_exception_call:
	movs r3,#OSServiceId_ReleaseResource
	svc #OSServiceId_ReleaseResource
	b ReleaseResource_exit_call
	/* Procedural call to the service */
ReleaseResource_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ReleaseResource<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
ReleaseResource_exit_call:
	bx lr
	/* 
	 * Service GetAlarmBase
	 */
	.global GetAlarmBase
	.type   GetAlarmBase, %function
GetAlarmBase:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetAlarmBase_direct_call
	/* Exception call to the service : use SVC exception */
GetAlarmBase_exception_call:
	movs r3,#OSServiceId_GetAlarmBase
	svc #OSServiceId_GetAlarmBase
	b GetAlarmBase_exit_call
	/* Procedural call to the service */
GetAlarmBase_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetAlarmBase<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
GetAlarmBase_exit_call:
	bx lr
	/* 
	 * Service GetAlarm
	 */
	.global GetAlarm
	.type   GetAlarm, %function
GetAlarm:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetAlarm_direct_call
	/* Exception call to the service : use SVC exception */
GetAlarm_exception_call:
	movs r3,#OSServiceId_GetAlarm
	svc #OSServiceId_GetAlarm
	b GetAlarm_exit_call
	/* Procedural call to the service */
GetAlarm_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetAlarm<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
GetAlarm_exit_call:
	bx lr
	/* 
	 * Service SetRelAlarm
	 */
	.global SetRelAlarm
	.type   SetRelAlarm, %function
SetRelAlarm:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SetRelAlarm_direct_call
	/* Exception call to the service : use SVC exception */
SetRelAlarm_exception_call:
	movs r3,#OSServiceId_SetRelAlarm
	svc #OSServiceId_SetRelAlarm
	b SetRelAlarm_exit_call
	/* Procedural call to the service */
SetRelAlarm_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SetRelAlarm<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
SetRelAlarm_exit_call:
	bx lr
	/* 
	 * Service SetAbsAlarm
	 */
	.global SetAbsAlarm
	.type   SetAbsAlarm, %function
SetAbsAlarm:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SetAbsAlarm_direct_call
	/* Exception call to the service : use SVC exception */
SetAbsAlarm_exception_call:
	movs r3,#OSServiceId_SetAbsAlarm
	svc #OSServiceId_SetAbsAlarm
	b SetAbsAlarm_exit_call
	/* Procedural call to the service */
SetAbsAlarm_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SetAbsAlarm<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
SetAbsAlarm_exit_call:
	bx lr
	/* 
	 * Service CancelAlarm
	 */
	.global CancelAlarm
	.type   CancelAlarm, %function
CancelAlarm:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq CancelAlarm_direct_call
	/* Exception call to the service : use SVC exception */
CancelAlarm_exception_call:
	movs r3,#OSServiceId_CancelAlarm
	svc #OSServiceId_CancelAlarm
	b CancelAlarm_exit_call
	/* Procedural call to the service */
CancelAlarm_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_CancelAlarm<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {pc}
	/* Function call */
CancelAlarm_exit_call:
	bx lr


#define API_STOP_SEC_CODE
#include "tpl_as_memmap.h"


/* End of file tpl_invoque.S */

